package days.c08

import utils.measureExecutionTime
import utils.printLine
import utils.printTestResult
import utils.readInput
import kotlin.math.abs

fun main() {
    val inputTest = readInput("inputC8e")
    val input = readInput("inputC8")

    measureExecutionTime({
        val resultTest = countAntinodes(inputTest)
        println("Total number of antinode locations (Part One - Test): $resultTest")
        printTestResult(resultTest, 14)

    }, "MAIN - PART ONE - Test")
    printLine()

    measureExecutionTime({
        val result = countAntinodes(input)
        println("Total number of antinode locations (Part One): $result")
    }, "MAIN - PART ONE")
    printLine()

    measureExecutionTime({
//        val resultTest = 0
//        printTestResult(resultTest, 0)
    }, "MAIN - PART TWO - Test")
    printLine()

    measureExecutionTime({}, "MAIN - PART TWO")
    printLine()
}

/**
 * This function calculates the number of unique antinodes generated by antennas on a map.
 * Each antinode is a specific point aligned with two antennas of the same frequency,
 * and located at a distance twice the separation of the antennas. Antinodes are only
 * counted if they fall within the bounds of the map.
 *
 * @param map A list of strings representing the map. Each character represents either
 * an antenna (a letter, digit, or symbol) or empty space (e.g., '.').
 * @return The count of unique locations that contain an antinode within the map bounds.
 */
fun countAntinodes(map: List<String>): Int {
    // Step 1: Map each antenna type to its positions on the grid
    val antennas = mutableMapOf<Char, MutableList<Pair<Int, Int>>>()

    for (y in map.indices) {
        for (x in map[y].indices) {
            val char = map[y][x]
            if (char.isLetterOrDigit()) {
//                if (antennas.containsKey(char)) {
//                    antennas[char]?.add(Pair(x, y))
//                } else {
//                    antennas[char] = mutableListOf(Pair(x, y))
//                }
                // Add the position of the antenna to the map.
                antennas.computeIfAbsent(char) { mutableListOf() }.add(Pair(x, y))

            }
        }
    }

    // Step 2: Calculate unique antinode locations
    val antinodes = mutableSetOf<Pair<Int, Int>>()

    for (positions in antennas.values) {
        if (positions.size < 2) continue // Skip if there are fewer than two antennas of the same type

        // Iterate through all unique pairs of antenna positions
        for (i in positions.indices) {
            for (j in i + 1..<positions.size) {
                // x -> ROW
                // y -> COL
                val (x1, y1) = positions[i]
                val (x2, y2) = positions[j]

                // Calculate the vector difference between the two antennas
                val deltaX = x2 - x1
                val deltaY = y2 - y1

                // Calculate the positions of the two possible antinodes
                val antinode1 = Pair(x1 + 2 * deltaX, y1 + 2 * deltaY)
                val antinode2 = Pair(x2 - 2 * deltaX, y2 - 2 * deltaY)

                // Add antinode1 if it is within the map bounds
                if (antinode1.first in map[0].indices && antinode1.second in map.indices) {
                    antinodes.add(antinode1)
                }

                // Add antinode2 if it is within the map bounds
                if (antinode2.first in map[0].indices && antinode2.second in map.indices) {
                    antinodes.add(antinode2)
                }
            }
        }
    }

    // Return the count of unique antinode positions
    return antinodes.size
}